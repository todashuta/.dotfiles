""" vimrc

let s:is_windows = has('win32')
let $VIMDIR = resolve(expand(s:is_windows ? '~/vimfiles' : '~/.vim'))
let $MYVIMRC = resolve($MYVIMRC)

if has('vim_starting')
  silent! autocmd! vimrcEx
  filetype off
  filetype plugin indent off
  if s:is_windows
    "let $HOME = $HOME  " See :h $HOME-windows
    "let $PATH .= ';'.expand('~/bin')
    "let $PATH .= ';'.'C:\Windows\Microsoft.NET\Framework64\v4.0.30319'
  endif
  let s:myrtp = join(glob($VIMDIR.'/plugins/*[^~]', 0, 1), ',')
  if s:myrtp != ''
    let &runtimepath .= ','.s:myrtp
  endif
  unlet s:myrtp
  "helptags ALL
endif

if &encoding !=? 'utf-8' && !filereadable($VIMDIR.'/use_system_encoding.txt')
  let &termencoding = &encoding
  set encoding=utf-8
endif
scriptencoding utf-8  " Must after set of 'encoding'.

if exists('+shellslash')
  set noshellslash
endif

if s:is_windows
  language messages en
else
  language messages C
endif

augroup vimrc
  autocmd!
augroup END

set viminfo+=c viminfo+=n~/var/vim/.viminfo
set swapfile directory=~/var/vim/swap
set undofile undodir=~/var/vim/undo
set nobackup writebackup backupdir=~/var/vim/backup

set helplang=ja,en
set fileformats=unix,dos,mac
set nofixendofline
set history=800
set noexpandtab tabstop=4 shiftwidth=4 softtabstop=0 shiftround
set incsearch ignorecase smartcase wrapscan
set hlsearch
set autoindent
set showmatch
set wildmenu
set laststatus=2 cmdheight=2 showcmd ruler
set nowrap
set list listchars=tab:>-,trail:-,extends:>,precedes:<,nbsp:%
set nonumber norelativenumber
set title
set backspace=indent,eol,start
set scrolloff=5 sidescrolloff=16
let g:FFTable = { 'dos': 'CR+LF(dos)', 'unix': 'LF(unix)', 'mac': 'CR(mac)' }
let &statusline = '%#WarningMsg#%{&paste?"*PASTE*":""}%*#%n%{MyGitStatus()} %#WarningMsg#%{&modified?"*":""}%*%<%t%h%r [%{toupper(&fenc==""?(&enc."*"):&fenc).(&bomb?"(BOM)":"")};%{g:FFTable[&ff].(&eol?"":"-NoEOL")}] 0x%{FencB()}%= %y %l/%LL %2c%VC %3p%%'
let &grepprg = s:is_windows ? 'jvgrep.exe -I -C' : 'grep -rnIH --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude=tags'
set grepformat& grepformat^=%f:%l:%c:%m
"set wildignore& wildignore+=*.exe,*.dll,*.zip,*.mp3,Thumbs.db,*.xls,*.xlsx,*.eml,*.fol,*.3dm,*.3dmbak,*.ods,*.odp,*.psd,*.pdf,*.bmp,*.jpg,*.jpeg,*.gif,*.png
"set suffixes+=.exe,.dll,.pdf,.jpg,.jpeg,.gif,.zip,.png
set hidden
set clipboard+=unnamed
set diffopt& diffopt+=vertical
if &diffopt =~# 'internal' && has('patch-8.1.0502')
  set diffopt+=algorithm:histogram,indent-heuristic
else
  set diffexpr=diff#histogramdiffexpr()  " https://github.com/ynkdir/vim-diff
endif
set timeoutlen=2000
set matchpairs+=<:>,「:」,【:】,『:』,（:）,＜:＞
set cscopetag tags& tags-=tags tags+=./tags;
set pumheight=10
set cryptmethod=blowfish2
set noequalalways
set shortmess-=S
set t_fd= t_fe=  " :h xterm-focus-event
silent! set nrformats= nrformats+=unsigned
"set updatetime=500
set previewheight=24
let &ambiwidth = has('kaoriya') ? 'auto' : 'double'
set winminwidth=16

"cnoremap          <C-x>       <C-r>=fnamemodify(@%,':h:~:.').(exists('+shellslash')&&!&shellslash?'\':'/')<CR>
cnoremap          <C-x>       <C-r>=(@%==''?'.':fnamemodify(@%,':~:.:h')).(exists('+shellslash')&&!&shellslash?'\':'/')<CR>
cnoremap          <C-p>       <Up>
cnoremap          <C-n>       <Down>
inoremap <expr>   <C-Space>   (!pumvisible() && &l:omnifunc != '') ? "\<C-x>\<C-o>" : "\<C-n>"
"inoremap <silent> <ESC>       <ESC>:set iminsert=0<CR>
inoremap          <C-@>       <Nop>
nnoremap          <C-h>       :<C-u>h<Space>
map               Q           <Nop>
nnoremap          s           <Nop>
xnoremap          s           <Nop>
nnoremap          S           <Nop>
nnoremap          <Space>/    :<C-u>silent grep!<Space>
nnoremap          <Space>?    :<C-u>/j **/* <Bar> cwindow<Home>noautocmd vimgrep /<C-f>
nnoremap <silent> <Esc><Esc>  :<C-u>let v:hlsearch = !v:hlsearch<CR>
nnoremap          <C-l>       :<C-u>call MyRedraw()<CR><C-l>

function! MyRedraw() abort
  call lightline#update()
  SignifyRefresh
  diffupdate
endfunction

if s:is_windows
  "nnoremap  se      :<C-u>Explorer<Space>
  "nnoremap  sE      :<C-u>Explorer!<CR>
  nnoremap  <C-w>N  :<C-u>!start gvim.exe<CR>
endif

nnoremap <Space>r  :<C-u>CtrlPMRUFiles<CR>
nnoremap <Space>b  :<C-u>CtrlPBuffer<CR>
nnoremap <Space>f  :<C-u>CtrlPCurWD<CR>
nnoremap <Space>F  :<C-u>CtrlPCurFile<CR>

nnoremap <Space>   <Nop>
xnoremap <Space>   <Nop>

nmap     <Space>s  <Plug>(toggle-split-orientation)

"nnoremap <Space>g  :<C-u>CtrlPLauncher! git<CR>
nnoremap <Space>g   <Nop>
nnoremap <Space>gg  :<C-u>Git<Space>
nnoremap <Space>gc  :<C-u>silent vert below Git commit<CR>
nnoremap <Space>ga  :<C-u>Gdiffsplit<CR>
nnoremap <Space>gf  :<C-u>Git fetch -p<Space>
nnoremap <Space>gb  :<C-u>Git blame<CR>
nnoremap <Space>gl  :<C-u>Git -p log<Space>
nnoremap <Space>gL  :<C-u>Git -p log --follow<Space>
nnoremap <Space>gd  :<C-u>CtrlPLauncher! gdiffsplit<CR>

nnoremap <Space>t   <Nop>
nnoremap <Space>tt  :<C-u>CtrlPLauncher! toggle<CR>
nnoremap <Space>tn  :<C-u>LineNumberToggle<CR>
nnoremap <Space>tw  :<C-u>setlocal wrap! wrap?<CR>
nnoremap <Space>t/  :<C-u>set wrapscan! wrapscan?<CR>
nnoremap <Space>ts  :<C-u>SignifyToggleHighlight<CR>
nnoremap <Space>tp  :<C-u>set paste! paste?<CR>

nnoremap <Space>l  :<C-u>CtrlPLauncher! lsp<CR>
nnoremap <Space>q  :<C-u>CtrlPLauncher quickrun<CR>
nnoremap <Space>w  :<C-u>CtrlPLauncher vimwiki<CR>
nnoremap <Space><F12>  :<C-u>CtrlPLauncher f12map<CR>
nnoremap <Space>e  :<C-u>call <SID>edit_buffer_directory()<CR>
function s:edit_buffer_directory()
  :e `=(@%==''?'.':fnamemodify(@%,':~:.:h')).(exists('+shellslash')&&!&shellslash?'\':'/')`
endfunction

nnoremap <expr> gc  '`[' . getregtype()[0] . '`]'

augroup vimrc
  autocmd QuickFixCmdPost [^l]*  botright cwindow | redraw!

  "autocmd VimEnter,WinEnter,ColorScheme *  highlight MatchParen guifg=NONE guibg=NONE ctermfg=NONE ctermbg=NONE term=underline cterm=underline gui=underline
  "autocmd VimEnter,WinEnter,ColorScheme *  highlight QuickFixLine guifg=NONE guibg=NONE ctermfg=NONE ctermbg=NONE term=underline cterm=underline gui=underline
  "autocmd VimEnter,WinEnter,ColorScheme *  if !has('gui_running') | execute 'highlight Normal ctermbg=NONE' | endif

  "autocmd VimEnter,WinEnter,ColorScheme *  if !has('gui_running') | execute 'highlight Pmenu ctermbg=3' | endif

  autocmd VimEnter,WinEnter,ColorScheme *  highlight clear ZenSpace | highlight link ZenSpace CursorColumn
  autocmd VimEnter,WinEnter,ColorScheme *  highlight lspReference term=underline cterm=underline gui=underline
  autocmd VimEnter,WinEnter,ColorScheme *  highlight link LspErrorHighlight SpellBad | highlight link LspWarningHighlight SpellLocal
  autocmd VimEnter,WinEnter,ColorScheme *  highlight link CursorWord0 CursorColumn | highlight link CursorWord1 CursorColumn

  autocmd FileType *  if &l:omnifunc == '' | setlocal omnifunc=syntaxcomplete#Complete | endif
augroup END

command!       CdCurrent               cd %:p:h
command!       EnableSyntaxcomplete    setlocal omnifunc=syntaxcomplete#Complete
command!       NrformatsAlphaToggle    exe 'setlocal nf'.(&nf =~# 'alpha' ? '-=' : '+=').'alpha nf?'
command!       PackUpdate              source $VIMDIR/packinit.vim | call minpac#update('', {'do': 'call minpac#status()'})
command!       PackClean               source $VIMDIR/packinit.vim | call minpac#clean()
command!       PackEdit                tabedit $VIMDIR/packinit.vim
command!       Swapfiles               echo iconv(system(v:progpath . ' -r'), &tenc, &enc)
command!       LineNumberToggle        let [&l:rnu, &l:nu] = (&l:rnu || &l:nu) ? [0, 0] : [1, 1]
command! -bang RemoveInvalidQfixItems  call setqflist(filter(copy(getqflist()), 'v:val.valid'), (<bang>0 ? 'r' : ' '))

function! s:term(cmd, dir, bang, vertical)
  let cwd = (a:dir != '' ? a:dir : (a:bang ? expand('%:p:h') : getcwd()))
  topleft call term_start(a:cmd, { 'vertical': a:vertical, 'term_finish': 'close', 'cwd': cwd, 'env': { 'VIM_TERMINAL': v:version } })
endfunction

command! -bang -complete=dir -nargs=? LTerminal  call s:term(&shell, <q-args>, <bang>0, 1)
command! -bang -complete=dir -nargs=? TTerminal  call s:term(&shell, <q-args>, <bang>0, 0)

if s:is_windows
  function! s:start(cmd, dir, bang)
    let cwd = (a:dir != '' ? a:dir : (a:bang ? expand('%:p:h') : getcwd()))
    call term_start(a:cmd, { 'term_finish': 'close', 'hidden': 1, 'cwd': cwd })
  endfunction

  command! -bang -complete=dir -nargs=? Cmd          execute 'silent !start cmd.exe /k pushd' tr((<q-args> != '' ? fnamemodify(<q-args>, ':p:h') : (<bang>0 ? expand('%:p:h') : getcwd())), '/', '\')
  command! -bang -complete=dir -nargs=? Explorer     call s:start('explorer.exe .', <q-args>, <bang>0)
  command!                     -nargs=1 MyCd         execute 'cd '.iconv(<q-args>, 'cp932', &enc)
  command! -bang -complete=dir -nargs=? PowerShell   call s:start('powershell.exe -Command "Start-Process powershell.exe"', <q-args>, <bang>0)
  command! -bang -complete=dir -nargs=? LTerminalPS  call s:term('powershell.exe', <q-args>, <bang>0, 1)
  command! -bang -complete=dir -nargs=? TTerminalPS  call s:term('powershell.exe', <q-args>, <bang>0, 0)
  command!                              Code         execute '!start code.cmd' shellescape(expand('%'))
endif

function! FencB()
  let c = matchstr(getline('.'), '.', col('.')-1)
  if c != ''
    let c = iconv(c, &enc, &fenc)
    return s:byte2hex(s:str2byte(c))
  else
    return '0'
  endif
endfunction

function! s:str2byte(str)
  return map(range(len(a:str)), 'char2nr(a:str[v:val])')
endfunction

function! s:byte2hex(bytes)
  return join(map(copy(a:bytes), 'printf("%02X", v:val)'), '')
endfunction

function! MyGitStatus() abort
  let l:xs = []

  let l:fugitive_status = FugitiveStatusline()
  if l:fugitive_status == ''
    return ''
  endif
  let l:fugitive_status = substitute(l:fugitive_status, '^[Git:\?', '', '')
  let l:fugitive_status = substitute(l:fugitive_status, ']$', '', '')
  let l:xs += [l:fugitive_status]

  "let l:gitbranchname = gitbranch#name()
  "if l:gitbranchname == ''
  "  return ''
  "endif
  "let l:is_index = get(b:, 'fugitive_type', '') ==# 'blob' && &modifiable
  "let l:xs += [(l:is_index ? '*' : '') . '(' . l:gitbranchname . ')']

  let l:signify_stats = sy#repo#get_stats_decorated()
  if l:signify_stats != ''
    let l:xs += [l:signify_stats]
  endif

  return join(l:xs, ' ')
endfunction


let g:loaded_matchparen = 1
let g:loaded_netrw = 1
let g:loaded_netrwPlugin = 1
let g:loaded_getscript = 1
let g:loaded_getscriptPlugin = 1
let g:loaded_vimball = 1
let g:loaded_vimballPlugin = 1

let g:pascal_delphi = 1  " To highlight //-style comment
let g:is_bash = 1  " See :h ft-bash-syntax
let g:vim_json_conceal = 0  " See :h ft-json-syntax

" Packages
"packadd! matchit
packadd! ctrlp.vim
packadd! ctrlp-launcher
packadd! html5.vim
packadd! sonictemplate-vim
packadd! vim-molder
packadd! vim-jsx-pretty
packadd! syntax-vim-ex
packadd! vim-css3-syntax
packadd! vim-diff
packadd! vim-lucius
packadd! vim-color-spring-night
packadd! tokyonight-vim
packadd! vim-niceblock
packadd! vim-sandwich
packadd! vim-textobj-user
packadd! vim-textobj-syntax
packadd! vim-textobj-python
packadd! vim-quickrun
packadd! vim-qfreplace
packadd! vim-prettyprint
packadd! vim-signify
packadd! vim-zenspace
packadd! vim-fugitive
packadd! vim-parenmatch
packadd! vim-cursorword
packadd! async.vim
packadd! asyncomplete.vim
packadd! asyncomplete-lsp.vim
packadd! vim-lsp
packadd! vim-lsp-settings
packadd! vim-lsp-icons
packadd! vim-gitbranch
packadd! vim-toml
packadd! vim-findroot
packadd! switch.vim
packadd! vim-operator-user
packadd! vim-operator-replace
packadd! lightline.vim
packadd! lightline-lsp
packadd! vim-toggle-split-orientation
packadd! iceberg.vim
packadd! vim-notification
packadd! vimwiki
packadd! zig.vim
packadd! vim-quickhl
packadd! requirements.txt.vim

if exists('##TextChangedP')
  packadd! vim-vsnip
  packadd! vim-vsnip-integ
endif

let s:denops_available = executable('deno') && has('patch-8.2.3452')
if get(s:, 'denops_available')
  packadd! denops.vim
  packadd! denops-helloworld.vim
  packadd! skkeleton
endif


" ctrlp.vim
let g:ctrlp_map = ''
let g:ctrlp_mruf_max = 512
"let g:ctrlp_show_hidden = 1
let g:ctrlp_launcher_file = $VIMDIR . '/ctrlp-launcher'
let g:ctrlp_status_func = {
      \   'main': 'CtrlPStatusFunc_main',
      \   'prog': 'CtrlPStatusFunc_progress',
      \ }
function! CtrlPStatusFunc_main(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  let g:lightline.ctrlp_marked = a:marked
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_numscanned = 0
  return lightline#statusline(0)
endfunction
function! CtrlPStatusFunc_progress(numscanned)
  let g:lightline.ctrlp_numscanned = a:numscanned
  return lightline#statusline(0)
endfunction
let g:ctrlp_buffer_func = {
      \   'exit': 'CtrlPBufferFunc_exit',
      \ }
function! CtrlPBufferFunc_exit()
  call timer_start(0, { -> lightline#update() })
endfunction


let g:sonictemplate_vim_template_dir = [ expand($VIMDIR.'/template') ]
call add(g:sonictemplate_vim_template_dir, expand($VIMDIR.'/template-bpy'))

let g:molder_show_hidden = 1
let g:quickrun_config = {}
let g:quickrun_config['_'] = {
      \   'runner': (exists('*ch_close_in') ? 'job' : 'vimproc'),
      \   'outputter': (exists('*deletebufline') ? 'buffer' : 'buffer_legacy'),
      \   'outputter/buffer/opener': 'new',
      \   'time/enable': 1,
      \   'time/format': '[QuickRun] *** time: %g ***',
      \   'time/dest': 'message',
      \   'message/log': 1,
      \   'running_mark': "(*'_')> じっこうちゅう...",
      \ }
if s:is_windows && executable('py')
  let g:quickrun_config['py'] = {
        \   'type': 'python',
        \   'command': 'py',
        \ }
  let g:quickrun_config['py/3.11'] = {
        \   'type': 'python',
        \   'command': 'py',
        \   'cmdopt': '-3.11',
        \ }
  let g:quickrun_config['py/3.10'] = {
        \   'type': 'python',
        \   'command': 'py',
        \   'cmdopt': '-3.10',
        \ }
  let g:quickrun_config['py/3.9'] = {
        \   'type': 'python',
        \   'command': 'py',
        \   'cmdopt': '-3.9',
        \ }
  let g:quickrun_config['py/3.8'] = {
        \   'type': 'python',
        \   'command': 'py',
        \   'cmdopt': '-3.8',
        \ }
endif
let g:switch_mapping = 'gs'
let g:cursorword_highlight = 0
let g:cursorword = 0
"let g:fugitive_dynamic_colors = 0


" lightline
let g:lightline = {
      \   'colorscheme': 'iceberg',
      \   'component_function': {
      \     'git': 'MyGitStatus',
      \     'myfilename': 'MyFilename',
      \     'mywintype': 'MyWinType',
      \     'myfiletype': 'MyFiletype',
      \   },
      \   'component': {
      \     'mycharvaluehex': '%<0x%{FencB()}',
      \     'myfileformat': '%{g:FFTable[&ff].(&eol?"":"-NoEOL")}',
      \     'myfileencoding': '%{toupper(&fenc==""?(&enc."*"):&fenc).(&bomb?"(BOM)":"")}',
      \   },
      \   'component_expand': {
      \     'lsp_warnings': 'lightline_lsp#warnings',
      \     'lsp_errors':   'lightline_lsp#errors',
      \   },
      \   'component_type': {
      \     'lsp_warnings': 'warning',
      \     'lsp_errors':   'error',
      \   },
      \   'active': {
      \     'left': [
      \       ['paste', 'mywintype'],
      \       ['git'],
      \       ['readonly', 'myfilename', 'modified'],
      \     ],
      \     'right': [
      \       ['lsp_errors', 'lsp_warnings', 'lineinfo'],
      \       ['percent'],
      \       ['mycharvaluehex', 'myfileformat', 'myfileencoding', 'myfiletype'],
      \     ],
      \   },
      \   'inactive': {
      \     'left': [
      \       ['mywintype'],
      \       ['git'],
      \       ['myfilename'],
      \     ],
      \   },
      \   'mode_map': {
      \     'n': 'Vim',
      \     'i': 'Ins',
      \     'R': 'Rep',
      \     'v': 'V-C',
      \     'V': 'V-L',
      \     "\<C-v>": 'V-B',
      \     'c': 'Cmd',
      \     's': 'S-C',
      \     'S': 'S-L',
      \     "\<C-s>": 'S-B',
      \     't': 'Terminal',
      \   },
      \   'subseparator': {'left': '', 'right': ''},
      \ }

function! MyFilename() abort
  if &filetype ==# 'ctrlp' && get(g:lightline, 'ctrlp_numscanned', 0) > 0
    return g:lightline.ctrlp_numscanned . ' files... (press ctrl-c to abort)'
  endif
  if &filetype ==# 'ctrlp' && has_key(g:lightline, 'ctrlp_item')
    let l:regmark = g:lightline.ctrlp_regex ? '[.*] ' : '[  ] '
    return l:regmark . join([
          \   ('<' . g:lightline.ctrlp_prev . '>'),
          \   ('{' . g:lightline.ctrlp_item . '}'),
          \   ('<' . g:lightline.ctrlp_next . '>'),
          \ ], '=') . g:lightline.ctrlp_marked
  endif
  if &buftype ==# 'quickfix' && get(w:, 'quickfix_title', '') != ''
    return w:quickfix_title
  endif
  let name = fnamemodify(@%, ':t') " expand('%:t')
  return name != '' ? name : '[No Name]'
endfunction

function! MyFiletype() abort
  let ft = &ft !=# '' ? &ft : 'no-ft'
  if get(w:, 'current_syntax', '') !=# ''
    let ft = w:current_syntax . '/' . ft
  endif
  return ft
endfunction

function! MyWinType() abort
  if get(b:, 'mybufnameoverride', '') !=# ''
    return '{' . b:mybufnameoverride . '}'
  endif
  if get(b:, 'mydifforigbuf', 0)
    return 'DiffOrig'
  endif
  if &buftype ==# 'terminal'
    let l:bnr = bufnr('')
    if term_getstatus(l:bnr) =~# 'finished'
      return 'Terminal-exited:' . string(job_info(term_getjob(l:bnr))['exitval'])
    else
      return 'Terminal'
    endif
  endif
  let l:cmdwintype = getcmdwintype()
  if l:cmdwintype != ''
    return l:cmdwintype
  endif
  let l:ret = get({
        \   '': '--',
        \   'ctrlp': 'CtrlP',
        \   'fugitive': 'Git',
        \   'fugitiveblame': 'Git',
        \   'help': 'Help',
        \   'qf': 'QuickFix',
        \ }, &filetype, &filetype)
  return &modifiable ? l:ret : ('*'.l:ret.'*')
  "let w = winnr()
  "return bufnr('').'|'.w.(w==winnr('#')?'#':'')
endfunction


xnoremap <expr> gr  niceblock#force_blockwise('r')
map sR  <Plug>(operator-replace)

omap aa  <Plug>(textobj-sandwich-auto-a)
omap ii  <Plug>(textobj-sandwich-auto-i)
xmap aa  <Plug>(textobj-sandwich-auto-a)
xmap ii  <Plug>(textobj-sandwich-auto-i)


" vim-signify
let g:signify_skip = {'vcs': {'allow': ['git']}}
autocmd vimrc User SignifyHunk call s:show_current_hunk()
function! s:show_current_hunk() abort
  let h = sy#util#get_hunk_stats()
  if !empty(h)
    redraw
    echo printf('[Hunk %d/%d]', h.current_hunk, h.total_hunks)
  endif
endfunction


" vim-sandwich
let g:sandwich#recipes = deepcopy(g:sandwich#default_recipes)
let g:sandwich#recipes += [
      \   {'buns': ['「', '」']},
      \   {'buns': ['【', '】']},
      \   {'buns': ['『', '』']},
      \   {'buns': ['（', '）']},
      \   {'buns': ['＜', '＞']},
      \ ]


" colorscheme
if has('termguicolors') && v:version > 800
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
  "let &t_8f = tr(&t_8f, ';', ':')
  "let &t_8b = tr(&t_8b, ';', ':')
  set termguicolors
endif

if !has('gui_running')
  autocmd vimrc ColorScheme
        \ * if &background ==# 'dark'
        \ |   execute 'highlight Normal ctermbg=NONE guibg=NONE'
        \ | endif
endif

let g:tokyonight_disable_italic_comment = 1
let g:tokyonight_transparent_background = 1
let g:tokyonight_menu_selection_background = 'blue'

let g:gruvbox_italic = 0

if has('vim_starting') && !has('gui_running')
  set background=dark
  if s:is_windows
    colorscheme industry
  else
    "colorscheme ron
    "colorscheme tokyonight
    colorscheme iceberg
  endif
endif


" vim-lsp
let g:lsp_log_file = expand('~/var/vim/vim-lsp.log')
let g:asyncomplete_log_file = expand('~/var/vim/asyncomplete.log')
let g:lsp_diagnostics_signs_priority = 11  " To precedence over signify's sign
let g:lsp_diagnostics_echo_cursor = 1

autocmd vimrc User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
function! s:on_lsp_buffer_enabled() abort
  let g:lsp_diagnostics_signs_error['text']   = 'E'
  let g:lsp_diagnostics_signs_warning['text'] = 'W'

  setlocal omnifunc=lsp#complete
  setlocal signcolumn=yes
  setlocal tagfunc=lsp#tagfunc

  nmap <buffer> K   <Plug>(lsp-hover)
  nmap <buffer> gd  <Plug>(lsp-definition)

  imap <buffer><C-space>  <Plug>(asyncomplete_force_refresh)

  "nnoremap <silent><buffer> [e  :<C-u>LspPreviousDiagnostic<CR>
  "nnoremap <silent><buffer> ]e  :<C-u>LspNextDiagnostic<CR>
endfunction

autocmd vimrc User lsp_float_opened call popup_setoptions(
      \ lsp#ui#vim#output#getpreviewwinid(),
      \ {
      \   'borderchars': ['-', '|', '-', '|', '+', '+', '+', '+'],
      \ })

let s:npm_available = executable('npm')
let g:lsp_settings = {
      \   'efm-langserver': {
      \     'cmd': [lsp_settings#exec_path('efm-langserver'), '-c='.$VIMDIR.'/efm-langserver-config.yaml'],
      \     'blocklist': ['vimwiki'],
      \     'disabled': !executable('go') || 0,
      \   },
      \   'clangd': {
      \     'cmd': ['clangd-6.0'],
      \     'disabled': !executable('clangd-6.0') || 0,
      \   },
      \   'intelephense': {
      \     'disabled': !s:npm_available || 0,
      \     'workspace_config': {
      \       'intelephense': {
      \         'stubs': ['wordpress'],
      \       }
      \     }
      \   },
      \   'vim-language-server': {
      \     'disabled': !s:npm_available || 0,
      \   },
      \   'typescript-language-server': {
      \     'disabled': !s:npm_available || 0,
      \   },
      \   'json-languageserver': {
      \     'disabled': !s:npm_available || 0,
      \     'workspace_config': {
      \       'json': {
      \         'schemas': [
      \           {
      \             'fileMatch': [ '*.gltf' ],
      \             'url': 'https://raw.githubusercontent.com/KhronosGroup/glTF/main/specification/2.0/schema/glTF.schema.json'
      \           }
      \         ]
      \       }
      \     }
      \   },
      \ }


autocmd vimrc FileType json
      \ call s:join_block_keymaps()
function! s:join_block_keymaps()
  nnoremap <buffer> <F9>    :<C-u>normal! v%J+<CR><Esc>
  nnoremap <buffer> <S-F9>  :<C-u>call feedkeys("vi[:g/{$/normal! v%J<Bslash><lt>CR>0zz", 'n')<CR>
endfunction

autocmd vimrc FileType json
      \ call s:set_json_indent()
function! s:set_json_indent()
  call cursor(1, 1)
  if search('\t', 'Wnc', 0, 20) > 0
    " use tab indentation (global value)
  else
    setlocal expandtab softtabstop=2 shiftwidth=2
  endif
endfunction

nnoremap <silent> <C-p>  :<C-u>call <SID>QFPrevious()<CR>
nnoremap <silent> <C-n>  :<C-u>call <SID>QFNext()<CR>
function! s:QFPrevious()
  if getwininfo(win_getid())[0].quickfix
    echo 'QFPrevious NOOP'
    return
  endif
  let xs = filter(copy(getwininfo()), 'v:val.tabnr == tabpagenr()')
  if len(filter(copy(xs), 'v:val.loclist')) > 0
    lprevious | normal! zz
  elseif len(filter(copy(xs), 'v:val.quickfix')) > 0
    cprevious | normal! zz
  else
    echo 'QFPrevious NOOP'
  endif
endfunction
function! s:QFNext()
  if getwininfo(win_getid())[0].quickfix
    echo 'QFNext NOOP'
    return
  endif
  let xs = filter(copy(getwininfo()), 'v:val.tabnr == tabpagenr()')
  if len(filter(copy(xs), 'v:val.loclist')) > 0
    lnext | normal! zz
  elseif len(filter(copy(xs), 'v:val.quickfix')) > 0
    cnext | normal! zz
  else
    echo 'QFNext NOOP'
  endif
endfunction

"set pythonthreedll=C:/Python37/python37.dll
"set pythonthreedll=~/scoop/apps/python/current/python310.dll
"packadd! vimdoc-ja

nnoremap <silent> <Space>d  :<C-u>call <SID>MyDiffOrigToggle()<CR>
function! s:MyDiffOrigToggle()
  let l:mydifforig_wins = filter(range(1, winnr('$')), 'getbufvar(winbufnr(v:val), "mydifforigbuf", 0)')
  if len(l:mydifforig_wins) > 0
    diffoff!
    for l:w in l:mydifforig_wins
      exe 'bwipeout' winbufnr(l:w)
    endfor
  else
    vert new | set bt=nofile | let b:mydifforigbuf = 1 | r ++edit # | 0d_ | diffthis | wincmd p | diffthis
  endif
endfunction

command! -nargs=? Name :let b:mybufnameoverride = <q-args>
command! IPython :terminal python -m IPython

command! ToggleBackground  call s:cmd_ToggleBackground()
function! s:cmd_ToggleBackground()
  let supported_colorschemes = ['iceberg']
  if index(supported_colorschemes, g:colors_name) < 0
    return
  endif
  let &background = &background ==# 'dark' ? 'light' : 'dark'
  let g:lightline.colorscheme = g:colors_name
  exe 'runtime autoload/lightline/colorscheme/'.g:colors_name.'.vim'
  call lightline#init() | call lightline#colorscheme() | call lightline#update()
endfunction

command! WinfixHeight  call feedkeys("\<C-Bslash>\<C-n>:set wfh | exe 'resize' string(\<C-r>=winheight(0)\<CR>)\<Left>", 'n')
command! WinfixWidth   call feedkeys("\<C-Bslash>\<C-n>:set wfw | exe 'vert resize' string(\<C-r>=winwidth(0)\<CR>)\<Left>", 'n')

"command! WinIgnoreToggle
"      \ : let b:winignore = !get(b:, 'winignore', 1)
"      \ | echo (b:winignore ? 'This window will be ignored.' : 'This window will NOT be ignored.')
"nnoremap <silent> <C-w><C-w>  :<C-u>call <SID>winignore_wincmd_w()<CR>
"tnoremap <silent> <C-w><C-w>  <C-\><C-n>:<C-u>call <SID>winignore_wincmd_w()<CR>
function! s:winignore_wincmd_w() abort
  let l:curwin = winnr()
  let l:targets = []
  for l:w in range(1, winnr('$'))
    let l:ignore = 0
    if getwinvar(l:w, '&filetype', '') =~# '^\%(fugitive\|qf\|help\)$'
      let l:ignore = 1
    endif
    if getwinvar(l:w, '&buftype', '') =~# '^\%(terminal\)$'
      let l:ignore = 1
    endif
    if getwinvar(l:w, '&previewwindow', 0)
      let l:ignore = 1
    endif
    let l:override = getbufvar(winbufnr(l:w), 'winignore', -1)
    if l:override >= 0
      let l:ignore = l:override
    endif
    if !l:ignore
      call add(l:targets, l:w)
    endif
  endfor
  if empty(l:targets)
    return
  endif
  if index(l:targets, l:curwin) >= 0
    let l:i = (index(l:targets, l:curwin) + 1) % len(l:targets)
    exe l:targets[l:i] . 'wincmd w'
  else
    exe l:targets[0] . 'wincmd w'
  endif
endfunction

" vim-quickhl
nmap <Space>m  <Plug>(quickhl-manual-this-whole-word)
xmap <Space>m  <Plug>(quickhl-manual-this)
nmap <Space>M  <Plug>(quickhl-manual-reset)

" Vimwiki
"let g:vimwiki_list = [{'path': '~/vimwiki/'}]
let g:vimwiki_diary_months = {}
call map(range(1, 12), 'extend(g:vimwiki_diary_months, {v:val: v:val."月"})')
let g:vimwiki_autowriteall = 0
let g:vimwiki_ext2syntax = {}

"command! -bang          Add     :exe <bang>0 ? 'Gwrite' : 'Gdiffsplit'
"command! -bang -nargs=* Commit  :exe 'silent Git ' . (<bang>0 ? '-c "commit.verbose=false"' : '') . ' commit <args>' | wincmd L
"command! -bang -nargs=+ Log     :exe 'Git ' . (<bang>0 ? '' : '-p') . ' log --follow <args>'
"command!                Blame   :exe 'Git blame'
"command! -nargs=*       Fetch   :exe 'Git fetch -p <args>'

command! -nargs=* QR  :exe &modified ? 'echo "modified!"' : 'QuickRun <args>'

command! ResizeInteractive  :call s:ResizeInteractive()
function! s:ResizeInteractive()
  while 1
    let c = getchar()
    if c == "\<Up>"
      wincmd +
    elseif c == "\<Down>"
      wincmd -
    elseif c == "\<Left>"
      wincmd <
    elseif c == "\<Right>"
      wincmd >
    else
      break
    endif
    redraw
  endwhile
  redraw
endfunction

function! OperatorSlashToBackslash(motion_wise)
  let save_reg_0 = [@0, getregtype('0')]
  let v = operator#user#visual_command_from_wise_name(a:motion_wise)
  execute 'normal!' '`[' . v . '`]"0y'
  let @0 = substitute(@0, '/', '\', 'g')
  execute 'normal!' '`[' . v . '`]"0P`['
  call setreg('0', save_reg_0[0], save_reg_0[1])
endfunction
call operator#user#define('slash2backslash', 'OperatorSlashToBackslash')
map s\  <Plug>(operator-slash2backslash)

function! OperatorBackslashToSlash(motion_wise)
  let save_reg_0 = [@0, getregtype('0')]
  let v = operator#user#visual_command_from_wise_name(a:motion_wise)
  execute 'normal!' '`[' . v . '`]"0y'
  let @0 = substitute(@0, '\', '/', 'g')
  execute 'normal!' '`[' . v . '`]"0P`['
  call setreg('0', save_reg_0[0], save_reg_0[1])
endfunction
call operator#user#define('backslash2slash', 'OperatorBackslashToSlash')
map s/  <Plug>(operator-backslash2slash)

function! Deg2rad(deg)
  let pi = acos(-1.0)
  return a:deg * pi / 180.0
endfunction
function! OperatorDeg2rad(motion_wise)
  let save_reg_0 = [@0, getregtype('0')]
  let v = operator#user#visual_command_from_wise_name(a:motion_wise)
  execute 'normal!' '`[' . v . '`]"0y'
  let @0 = printf('%f', Deg2rad(str2float(@0)))
  execute 'normal!' '`[' . v . '`]"0P`['
  call setreg('0', save_reg_0[0], save_reg_0[1])
endfunction
call operator#user#define('deg2rad', 'OperatorDeg2rad')
"map <F11> <Plug>(operator-deg2rad)

function! Rad2deg(rad)
  let pi = acos(-1.0)
  return a:rad * 180.0 / pi
endfunction
function! OperatorRad2deg(motion_wise)
  let save_reg_0 = [@0, getregtype('0')]
  let v = operator#user#visual_command_from_wise_name(a:motion_wise)
  execute 'normal!' '`[' . v . '`]"0y'
  let @0 = printf('%f', Rad2deg(str2float(@0)))
  execute 'normal!' '`[' . v . '`]"0P`['
  call setreg('0', save_reg_0[0], save_reg_0[1])
endfunction
call operator#user#define('rad2deg', 'OperatorRad2deg')
"map <F12> <Plug>(operator-rad2deg)

let s:vimrclocal = $MYVIMRC.'_local'
if filereadable(s:vimrclocal)
  execute 'source' s:vimrclocal
endif

filetype plugin indent on
syntax enable
set secure

""" vim: set et ts=2 sts=2 sw=2:
""" vimrc ends here
